<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>研究紹介 | 松本崚佑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Montserrat:wght@700&display=swap" rel="stylesheet">
  <style>
    :root{
      --primary:#2c3e50;
      --accent:#18bc9c;
      --heat:#f5c400;     /* ヒートマップ黄色 */
      --bg:#ecf0f1;
      --dark:#1a1a1a;
    }
    *,*::before,*::after{box-sizing:border-box}
    body{margin:0;font-family:"Noto Sans JP",sans-serif;background:var(--bg);color:var(--dark)}
    header,footer{background:var(--primary);color:#fff;text-align:center;padding:1rem 0}
    main{max-width:1000px;margin:2rem auto;padding:0 1.5rem}
    h1{margin:0;font-size:2.2rem;font-family:'Montserrat',sans-serif}
    h2{margin:2rem 0 1rem;font-size:1.6rem;color:var(--primary)}
    section{background:#fff;padding:1.5rem 2rem;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.05);margin-bottom:2.5rem}
    canvas,svg{display:block;margin:1rem auto;max-width:100%;border:1px solid #ddd;border-radius:6px;background:#fff}
    .caption{font-size:.9rem;color:#666;text-align:center}
    .connector{font-weight:700;font-size:1rem;color:var(--primary);margin:0 0 .5rem}
    /* Flow animation パーツ */
    .flow-part{opacity:0;transition:opacity .4s ease}
    .mini-wave{stroke:#fff;stroke-width:2;fill:none;stroke-linejoin:round;stroke-linecap:round}
  </style>
</head>
<body>
  <header>
    <h1>研究紹介</h1>
    <nav><a href="index.html" style="color:#fff;text-decoration:none">← トップへ戻る</a></nav>
  </header>

  <main>
    <!-- ───────── 図1 ───────── -->
    <section>
      <h2>生成AIを用いて心電図の補完を行う研究がされていた</h2>
      <canvas id="ecgCanvas" width="800" height="240"></canvas>
    </section>

    <!-- ───────── 図2 ───────── -->
    <section>
      <p class="connector">しかし</p>
      <h2>生成AIが出力した波形は生成プロセスが不明なので、医学、薬学分野で応用するには信頼度がたりない</h2>

      <svg id="flowSvg" viewBox="0 0 920 220" width="920" height="220">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary)"/>
          </marker>
          <style>
            .rect-in{fill:#cfcfcf}
            .rect-model{fill:var(--primary)}
            .rect-out{fill:var(--accent)}
            .arrow{stroke:var(--primary);stroke-width:3;fill:none;marker-end:url(#arrowhead)}
            text{fill:#fff;font-size:14px;font-family:'Noto Sans JP',sans-serif;dominant-baseline:middle;text-anchor:middle}
          </style>
        </defs>

        <!-- 入力 -->
        <g id="inputGroup" class="flow-part">
          <rect x="20" y="60" width="220" height="100" rx="8" class="rect-in"/>
          <text x="130" y="95">入力 ECG</text>
          <polyline points="40,130 60,100 80,160 100,40 120,180 140,130 160,110 180,110 200,130"
                    class="mini-wave"/>
        </g>

        <!-- 矢印1 -->
        <line id="arrow1" x1="240" y1="110" x2="400" y2="110" class="arrow flow-part"/>

        <!-- モデル -->
        <g id="modelGroup" class="flow-part">
          <rect x="400" y="50" width="160" height="120" rx="8" class="rect-model"/>
          <text x="480" y="95">生成モデル</text>
          <text x="480" y="120">(ブラックボックス)</text>
          <text id="qMark" x="480" y="35" font-size="28" fill="#fff" opacity="0">?</text>
        </g>

        <!-- 矢印2 -->
        <line id="arrow2" x1="560" y1="110" x2="720" y2="110" class="arrow flow-part"/>

        <!-- 出力 -->
        <g id="outputGroup" class="flow-part">
          <rect x="720" y="60" width="220" height="100" rx="8" class="rect-out"/>
          <text x="830" y="95">欠損部 ECG</text>
          <polyline points="740,130 760,100 780,160 800,40 820,180 840,130 860,110 880,110 900,130"
                    class="mini-wave"/>
        </g>
      </svg>
    </section>

    <!-- ───────── 図3 ───────── -->
    <section>
      <p class="connector">そのため</p>
      <h2>AIが生成する際に重要視している部分の可視化を行う研究をしている</h2>
      <canvas id="attentionCanvas" width="800" height="240"></canvas>
      <p class="caption">黄色が濃いほど生成に寄与した区間（虫眼鏡通過後に表示）</p>
    </section>
  </main>

  <footer>© 2025 松本崚佑</footer>

  <!-- ───────── JavaScript ───────── -->
  <script>
    /* -------------------- 共通定数 -------------------- */
    const ACCENT = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    const HEAT   = getComputedStyle(document.documentElement).getPropertyValue('--heat').trim();
    const CYCLE  = 6000;               // 3 図とも共有する 1 周期 (ms)

    /* ECG 波形関数（簡易モデル） */
    function ecgShape(p){  // p:0-100
      if(p<6)  return  6*Math.sin((p/6)*Math.PI);
      if(p<9)  return -10*(p-6);
      if(p<12) return 0;
      if(p<14) return -60*(p-12)/2;
      if(p<15) return 180*(p-14)-60;
      if(p<16) return -120*(p-15)+120;
      if(p<22) return 0;
      if(p<32) return  60*Math.sin(((p-22)/10)*Math.PI);
      return 0;
    }

    /* ==================================================
       図1：欠損補完アニメーション
       ================================================== */
    (()=>{
      const c=document.getElementById('ecgCanvas'); if(!c) return;
      const ctx=c.getContext('2d'), W=c.width, H=c.height, B=H/2;
      const cyc=250, pts=[], st=230, en=380;
      const WAVE_DUR = CYCLE*0.35;   // 波形補完にかける時間
      const WAIT     = CYCLE - WAVE_DUR;
      for(let x=0;x<=W;x++){const p=((x%cyc)/cyc)*100; pts.push({x,y:B-ecgShape(p)})}

      function drawBase(){
        ctx.clearRect(0,0,W,H);
        ctx.lineWidth=2; ctx.strokeStyle='#c0c0c0';
        ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y);
        for(let i=1;i<pts.length;i++){
          if(i===st){ctx.stroke();ctx.beginPath();ctx.moveTo(pts[en].x,pts[en].y);continue;}
          if(i>st&&i<en) continue;
          ctx.lineTo(pts[i].x,pts[i].y);
        }
        ctx.stroke();
      }

      function loop(){
        drawBase();
        const t0=performance.now();
        const frame=now=>{
          const pr=Math.min((now-t0)/WAVE_DUR,1);
          const len=Math.floor(pr*(en-st));
          ctx.clearRect(st-2,0,(en-st)+4,H);
          ctx.lineWidth=2; ctx.strokeStyle=ACCENT;
          ctx.beginPath(); ctx.moveTo(pts[st].x,pts[st].y);
          for(let i=1;i<=len;i++) ctx.lineTo(pts[st+i].x,pts[st+i].y);
          ctx.stroke();
          if(pr<1) requestAnimationFrame(frame);
          else     setTimeout(loop,WAIT);
        };
        requestAnimationFrame(frame);
      }
      loop();
    })();

    /* ==================================================
       図2：フロー図フェードイン
       ================================================== */
    (()=>{
      const ids=['inputGroup','arrow1','modelGroup','arrow2','outputGroup'];
      const delays=[0,700,1400,2100,2800];  // 各要素の表示タイミング
      function hideAll(){ ids.forEach(id=>document.getElementById(id).style.opacity=0); document.getElementById('qMark').style.opacity=0; }
      function showSeq(){
        ids.forEach( (id,i)=>{
          setTimeout(()=>{
            document.getElementById(id).style.opacity=1;
            if(id==='modelGroup'){ // ?マークをチラ見せ
              const q=document.getElementById('qMark');
              q.style.opacity=1; setTimeout(()=>q.style.opacity=0,600);
            }
          },delays[i]);
        });
      }
      (function loop(){
        hideAll();
        setTimeout(showSeq,200);
        setTimeout(loop,CYCLE);   // 全体周期と同期
      })();
    })();

    /* ==================================================
       図3：虫眼鏡スキャン + ヒートマップ
       ================================================== */
    (()=>{
      const c=document.getElementById('attentionCanvas'); if(!c) return;
      const ctx=c.getContext('2d'), W=c.width, H=c.height, B=H/2;
      const cyc=250, pts=[];
      for(let x=0;x<=W;x++){const p=((x%cyc)/cyc)*100; pts.push({x,y:B-ecgShape(p)})}

      // 虫眼鏡パラメータ
      const lensR=30;                       // レンズ半径
      const SCAN_TIME = CYCLE*0.5;          // 左→右に動く時間
      const START_DELAY = CYCLE*0.1;        // 波形生成完了からスキャン開始までの隙間
      const WAVE_DRAW_TIME = CYCLE*0.35;    // 波形を強調して描く時間（図1と同様）

      // 各点の寄与重み（ランダム例）
      const weights=new Array(pts.length).fill(0).map(()=>Math.random());

      /* 波形描画 */
      function drawWave(stroke='#666',lw=1.6,uptoIdx=pts.length){
        ctx.lineWidth=lw; ctx.strokeStyle=stroke;
        ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y);
        for(let i=1;i<uptoIdx;i++) ctx.lineTo(pts[i].x,pts[i].y);
        ctx.stroke();
      }

      /* ヒートマップ描画 */
      function drawHeat(uptoX){
        for(let i=0;i<pts.length;i+=4){
          if(pts[i].x>uptoX) continue;
          const a=weights[i]*0.6;
          ctx.fillStyle=`rgba(245,196,0,${a})`;
          ctx.fillRect(pts[i].x-2,0,4,H);
        }
      }

      /* 虫眼鏡描画 */
      function drawLens(x){
        ctx.save();
        ctx.translate(x, H/2);
        ctx.lineWidth=3; ctx.strokeStyle='#555';
        ctx.fillStyle='rgba(255,255,255,0.65)';
        ctx.beginPath(); ctx.arc(0,0,lensR,0,2*Math.PI); ctx.fill(); ctx.stroke();
        ctx.rotate(Math.PI/4);
        ctx.lineWidth=6;
        ctx.beginPath(); ctx.moveTo(lensR*0.7,0); ctx.lineTo(lensR*2.0,0); ctx.stroke();
        ctx.restore();
      }

      /* メインループ */
      let start=performance.now();
      function loop(now){
        const t=(now-start)%CYCLE;
        ctx.clearRect(0,0,W,H);

        // フェーズ 1: 波形をアクセント色で生成
        if(t<WAVE_DRAW_TIME){
          const pr=t/WAVE_DRAW_TIME;
          const upto=Math.floor(pr*pts.length);
          drawWave('#c0c0c0',1.6); // グレー下地
          drawWave(ACCENT,2.8,upto);
        }else{
          drawWave();
        }

        // フェーズ 2: 虫眼鏡スキャン & ヒートマップ
        const scanStart=WAVE_DRAW_TIME+START_DELAY;
        if(t>scanStart && t<scanStart+SCAN_TIME){
          const scanPr=(t-scanStart)/SCAN_TIME;
          const scanX=-lensR + scanPr*(W+lensR*2);
          drawHeat(scanX-lensR*0.8);
          drawLens(scanX);
        }else if(t>=scanStart+SCAN_TIME){
          drawHeat(W);
        }

        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
