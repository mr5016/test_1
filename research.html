<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>研究紹介 | 松本崚佑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Montserrat:wght@700&display=swap" rel="stylesheet">
  <style>
    :root{
      --primary:#2c3e50;
      --accent:#18bc9c;
      --bg:#ecf0f1;
      --white:#ffffff;
      --dark:#1a1a1a;
    }
    *,*::before,*::after{box-sizing:border-box;}
    body{margin:0;font-family:'Noto Sans JP',sans-serif;background:var(--bg);color:var(--dark);}  
    header,footer{background:var(--primary);color:#fff;text-align:center;padding:1rem 0;}
    a{color:var(--accent);text-decoration:none;}
    main{max-width:1000px;margin:2rem auto;padding:0 1.5rem;}
    h1{margin:0;font-size:2.2rem;font-family:'Montserrat',sans-serif;}
    h2{margin-top:3rem;font-size:1.6rem;color:var(--primary);}    
    section{background:#fff;padding:1.5rem 2rem;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.05);margin-bottom:2.5rem;position:relative;}
    canvas,svg{display:block;margin:1rem auto;max-width:100%;border:1px solid #ddd;border-radius:6px;background:#fff;}
    .caption{font-size:.9rem;color:#666;text-align:center;}
    .step-label{position:absolute;top:-1.2rem;left:1rem;background:var(--accent);color:#fff;padding:.1rem .5rem;border-radius:4px;font-size:.8rem;font-weight:700;}
  </style>
</head>
<body>
  <header>
    <h1>研究紹介</h1>
    <nav><a href="index.html">← トップへ戻る</a></nav>
  </header>
  <main>

    <!-- Step 1 -------------------------------------------------------------- -->
    <section id="step1">
      <span class="step-label">STEP&nbsp;1</span>
      <h2>心電図欠損補完に生成 AI を応用</h2>
      <p>欠損した心電図（ECG）波形を入力し、<strong>欠損していない前後の部分</strong>を条件として生成 AI が<br>欠損部分を推定・補完する手法を開発しています。</p>
      <!-- ECG Animation Canvas -->
      <canvas id="ecgCanvas" width="800" height="220"></canvas>
      <p class="caption">図 1：欠損波形（グレー）を生成 AI が補完（グリーン）するアニメーション（ループ再生）</p>
    </section>

    <!-- Step 2 -------------------------------------------------------------- -->
    <section id="step2">
      <span class="step-label">STEP&nbsp;2</span>
      <h2>ブラックボックス問題と信頼性</h2>
      <p>しかし、生成 AI が<strong>どのような特徴を手がかりに波形を生成したのか</strong>が分からないため、<br>医学・薬学への応用では <em>Explainability（説明可能性）</em> が課題となります。</p>
      <svg id="blackboxSvg" viewBox="0 0 760 200" width="800" height="200">
        <style>
          .arrow{fill:none;stroke:var(--primary);stroke-width:3;marker-end:url(#arrowhead);} 
          .input{fill:#cfcfcf;} .box{fill:var(--primary);} .output{fill:var(--accent);} 
          text{fill:#fff;font-size:14px;font-family:'Noto Sans JP',sans-serif;dominant-baseline:middle;text-anchor:middle;}
        </style>
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary)" />
          </marker>
        </defs>
        <!-- 左: 入力ECG -->
        <rect x="20" y="60" width="140" height="80" class="input" rx="6"/>
        <text x="90" y="100">入力 ECG</text>
        <!-- 直線矢印 -->
        <path d="M160 100 H 300" class="arrow" />
        <!-- ブラックボックス -->
        <rect x="300" y="40" width="160" height="120" class="box" rx="8"/>
        <text x="380" y="100">生成&nbsp;AI<br>(ブラック<br>ボックス)</text>
        <!-- 直線矢印 生成AI → 欠損ECG -->
        <path d="M460 100 H 600" class="arrow" />
        <!-- 右: 欠損部ECG -->
        <rect x="600" y="60" width="140" height="80" class="output" rx="6"/>
        <text x="670" y="100">欠損部 ECG</text>
      </svg>
      <p class="caption">図 2：入力 ECG → 生成 AI (ブラックボックス) → 欠損部 ECG の直線フロー</p>
    </section>

    <!-- Step 3 -------------------------------------------------------------- -->
    <section id="step3">
      <span class="step-label">STEP&nbsp;3</span>
      <h2>重要領域の可視化による Explainability 向上</h2>
      <p>生成 AI が<strong>入力波形のどこを重視して欠損部を生成したか</strong>を可視化し、<br>医療者が直感的に信頼度を判断できるようにする研究を行いました。</p>
      <canvas id="attentionCanvas" width="800" height="220"></canvas>
      <p class="caption">図 3：緑が濃い部分ほど生成に寄与したと推定される区間 (欠損生成部は除外)</p>
    </section>

  </main>
  <footer>© 2025 松本崚佑</footer>

  <script>
    const ACCENT=getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();

    /* ---- ECG helper: realistic synthetic beat (returns y offset) ---- */
    function ecgShape(phase){
      // phase: 0-100 (% of beat)
      if(phase<5)               return  2*phase;                   // small up: P start
      else if(phase<10)         return 10-2*phase;                 // back to baseline
      else if(phase<13)         return -20*(phase-10)/3;           // Q dip
      else if(phase<15)         return 35*(phase-13)/2 -20;        // R spike up
      else if(phase<17)         return -25*(phase-15)/2 +15;       // S drop
      else if(phase<25)         return 0;                          // baseline
      else if(phase<35)         return  15*Math.sin((phase-25)/10*Math.PI); // T wave up
      else if(phase<45)         return  15*Math.sin((phase-35)/10*Math.PI); // T wave down
      else                      return 0;                          // baseline
    }

    /* ---------------- ECG Animation (Step 1) - loop ---------------- */
    (function(){
      const canvas=document.getElementById('ecgCanvas'); if(!canvas)return;
      const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height,baseline=H/2;
      const cyclePx=200; // pixels per beat
      const totalPoints=W;
      const points=[];
      for(let x=0;x<totalPoints;x++){
        const phase=((x%cyclePx)/cyclePx)*100; // percentage
        const y=baseline - ecgShape(phase);
        points.push({x,y});
      }
      const start=300,end=450,duration=1500; // ms
      function drawBase(){
        ctx.clearRect(0,0,W,H);
        ctx.lineWidth=2; ctx.lineJoin='round'; ctx.strokeStyle='#c0c0c0';
        ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y);
        for(let i=1;i<points.length;i++){
          if(i===start){ctx.stroke(); ctx.beginPath(); ctx.moveTo(points[end].x,points[end].y); continue;}
          if(i>start && i<end) continue;
          ctx.lineTo(points[i].x,points[i].y);
        }
        ctx.stroke();
      }
      drawBase();
      function animate(){
        const tStart=performance.now();
        function frame(now){
          const progress=((now-tStart)%duration)/duration; const len=Math.floor(progress*(end-start));
          ctx.clearRect(start-1,0,(end-start)+2,H);
          ctx.strokeStyle=ACCENT; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(points[start].x,points[start].y);
          for(let i=1;i<=len;i++) ctx.lineTo(points[start+i].x,points[start+i].y);
          ctx.stroke();
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }
      animate();
    })();

    /* ---------------- Attention Heatmap & Generated Segment (Step 3) ------------ */
    (function(){
      const canvas=document.getElementById('attentionCanvas'); if(!canvas)return;
      const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height,baseline=H/2;
      const cyclePx=200; const points=[]; for(let x=0;x<=W;x++){const phase=((x%cyclePx)/cyclePx)*100; const y=baseline - ecgShape(phase); points.push({x,y});}
      const start=300,end=450;
      // draw full waveform (grey thin)
      ctx.lineWidth=1.6; ctx.strokeStyle='#666'; ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y);
      for(const p of points) ctx.lineTo(p.x,p.y); ctx.stroke();
      // draw generated segment overlay (bold green)
      ctx.lineWidth=2.8; ctx.strokeStyle=ACCENT; ctx.beginPath(); ctx.moveTo(points[start].x,points[start].y);
      for(let i=start+1;i<=end;i++) ctx.lineTo(points[i].x,points[i].y); ctx.stroke();

      // sparse attention weights outside generated segment
      const weights=new Array(points.length).fill(0);
      for(let i=0;i<points.length;i+=4){ if(i<start-20||i>end+20){ if(Math.random()<0.08){weights[i]=Math.random();} } }
      const max=Math.max(...weights);
      const barW=4; let idx=0;
      function drawBar(){
        if(idx>=points.length){return;} if(weights[idx]>0){ const alpha=(weights[idx]/(max||1))*0.55; ctx.fillStyle=`rgba(24,188,156,${alpha})`; ctx.fillRect(points[idx].x-barW/2,0,barW,H);} idx+=4; requestAnimationFrame(drawBar); }
      drawBar();
    })();
  </script>
</body>
</html>
