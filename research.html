<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>研究紹介 | 松本崚佑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Montserrat:wght@700&display=swap" rel="stylesheet">
  <style>
    :root{
      --primary:#2c3e50;
      --accent:#18bc9c;
      --heat:#f5c400; /* ヒートマップを黄色に */
      --bg:#ecf0f1;
      --white:#ffffff;
      --dark:#1a1a1a;
    }
    *,*::before,*::after{box-sizing:border-box;}
    body{margin:0;font-family:'Noto Sans JP',sans-serif;background:var(--bg);color:var(--dark);}  
    header,footer{background:var(--primary);color:#fff;text-align:center;padding:1rem 0;}
    a{color:var(--accent);text-decoration:none;}
    main{max-width:1000px;margin:2rem auto;padding:0 1.5rem;}
    h1{margin:0;font-size:2.2rem;font-family:'Montserrat',sans-serif;}
    h2{margin-top:3rem;font-size:1.6rem;color:var(--primary);}    
    section{background:#fff;padding:1.5rem 2rem;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.05);margin-bottom:2.5rem;position:relative;}
    canvas,svg{display:block;margin:1rem auto;max-width:100%;border:1px solid #ddd;border-radius:6px;background:#fff;}
    .caption{font-size:.9rem;color:#666;text-align:center;}
    .step-label{position:absolute;top:-1.2rem;left:1rem;background:var(--accent);color:#fff;padding:.1rem .5rem;border-radius:4px;font-size:.8rem;font-weight:700;}
    /* waveform inside rectangles (SVG) */
    .mini-wave{stroke:#fff;stroke-width:2;fill:none;stroke-linejoin:round;stroke-linecap:round;}
  </style>
</head>
<body>
  <header>
    <h1>研究紹介</h1>
    <nav><a href="index.html">← トップへ戻る</a></nav>
  </header>
  <main>

    <!-- Step 1 -------------------------------------------------------------- -->
    <section id="step1">
      <span class="step-label">STEP&nbsp;1</span>
      <h2>心電図欠損補完に生成 AI を応用</h2>
      <p>欠損した心電図（ECG）波形を入力し、<strong>欠損していない前後の部分</strong>を条件として生成 AI が<br>欠損部分を推定・補完する手法を開発しています。</p>
      <!-- ECG Animation Canvas -->
      <canvas id="ecgCanvas" width="800" height="240"></canvas>
      <p class="caption">図 1：欠損波形（グレー）を生成 AI が補完（グリーン）するアニメーション（ループ再生）</p>
    </section>

    <!-- Step 2 -------------------------------------------------------------- -->
    <section id="step2">
      <span class="step-label">STEP&nbsp;2</span>
      <h2>ブラックボックス問題と信頼性</h2>
      <p>生成 AI の内部プロセスが不透明なため、医学応用には説明可能性が必要です。</p>

      <!-- New simple SVG: Input → Model → Output -->
      <svg viewBox="0 0 900 200" width="900" height="200">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary)" />
          </marker>
          <style>
            .rect-in{fill:#cfcfcf;} .rect-model{fill:var(--primary);} .rect-out{fill:var(--accent);} .arrow{stroke:var(--primary);stroke-width:3;fill:none;marker-end:url(#arrowhead);} text{fill:#fff;font-size:14px;font-family:'Noto Sans JP',sans-serif;dominant-baseline:middle;text-anchor:middle;}
          </style>
        </defs>
        <!-- Input -->
        <rect x="30" y="50" width="220" height="100" rx="8" class="rect-in" />
        <text x="140" y="85">入力 ECG</text>
        <!-- simple wave line inside -->
        <polyline points="50,120 70,90 90,150 110,30 130,170 150,120 170,100 190,100 210,120" stroke="#fff" stroke-width="2" fill="none" stroke-linejoin="round" stroke-linecap="round" />
        <!-- Arrow -->
        <line x1="250" y1="100" x2="400" y2="100" class="arrow" />
        <!-- Model -->
        <rect x="400" y="40" width="150" height="120" rx="8" class="rect-model" />
        <text x="475" y="100">生成モデル</text>
        <text x="475" y="125">(ブラックボックス)</text>
        <!-- Arrow -->
        <line x1="550" y1="100" x2="700" y2="100" class="arrow" />
        <!-- Output -->
        <rect x="700" y="50" width="220" height="100" rx="8" class="rect-out" />
        <text x="810" y="85">欠損部 ECG</text>
        <polyline points="720,120 740,90 760,150 780,30 800,170 820,120 840,100 860,100 880,120" stroke="#fff" stroke-width="2" fill="none" stroke-linejoin="round" stroke-linecap="round" />
      </svg>
      <p class="caption">図 2：入力波形 → 生成モデル → 補完波形 のフロー</p>
    </section>

    <!-- Step 3 -------------------------------------------------------------- -->
    <section id="step3">
      <span class="step-label">STEP&nbsp;3</span>
      <h2>重要領域の可視化による Explainability 向上</h2>
      <p>生成 AI が<strong>入力波形のどこを重視して欠損部を生成したか</strong>を可視化し、<br>医療者が直感的に信頼度を判断できるようにする研究を行いました。</p>
      <canvas id="attentionCanvas" width="800" height="240"></canvas>
      <p class="caption">図 3：黄色が濃い部分ほど生成に寄与したと推定される区間 (欠損生成部は除外)</p>
    </section>

  </main>
  <footer>© 2025 松本崚佑</footer>

  <script>
    const ACCENT=getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    const HEAT=getComputedStyle(document.documentElement).getPropertyValue('--heat').trim();

    /* ---- ECG helper: realistic shape based on provided image ---- */
    function ecgShape(phase){
      if(phase<6)                    return 6*Math.sin((phase/6)*Math.PI);            // P up small
      else if(phase<9)               return -10*(phase-6);                            // dip
      else if(phase<12)              return 0;
      else if(phase<14)              return -60*(phase-12)/2;                         // Q
      else if(phase<15)              return 180*(phase-14) -60;                       // R peak up
      else if(phase<16)              return -120*(phase-15) +120;                     // S
      else if(phase<22)              return 0;
      else if(phase<32)              return 60*Math.sin(((phase-22)/10)*Math.PI);      // T wave
      else                           return 0;
    }

    /* ---------------- ECG Animation (Step 1) - loop ---------------- */
    (function(){
      const canvas=document.getElementById('ecgCanvas'); if(!canvas)return;
      const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height,baseline=H/2;
      const cyclePx=250; // pixels per beat
      const points=[];
      for(let x=0;x<=W;x++){
        const phase=((x%cyclePx)/cyclePx)*100;
        const y=baseline - ecgShape(phase);
        points.push({x,y});
      }
      const start=230,end=380,duration=2000; // ensure segment with peak
      function drawBase(){
        ctx.clearRect(0,0,W,H);
        ctx.lineWidth=2; ctx.lineJoin='round'; ctx.strokeStyle='#c0c0c0';
        ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y);
        for(let i=1;i<points.length;i++){
          if(i===start){ctx.stroke(); ctx.beginPath(); ctx.moveTo(points[end].x,points[end].y); continue;}
          if(i>start && i<end) continue;
          ctx.lineTo(points[i].x,points[i].y);
        }
        ctx.stroke();
      }
      drawBase();
      function animate(){
        const t0=performance.now();
        function frame(now){
          const p=((now-t0)%duration)/duration; const len=Math.floor(p*(end-start));
          ctx.clearRect(start-2,0,(end-start)+4,H);
          ctx.lineWidth=2; ctx.strokeStyle=ACCENT;
          ctx.beginPath(); ctx.moveTo(points[start].x,points[start].y);
          for(let i=1;i<=len;i++) ctx.lineTo(points[start+i].x,points[start+i].y);
          ctx.stroke();
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }
      animate();
    })();

    /* ---------------- Attention Heatmap & Generated Segment (Step 3) ------------ */
    (function(){
      const canvas=document.getElementById('attentionCanvas'); if(!canvas)return;
      const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height,baseline=H/2;
      const cyclePx=250; const points=[];
      for(let x=0;x<=W;x++){ const phase=((x%cyclePx)/cyclePx)*100; const y=baseline - ecgShape(phase); points.push({x,y}); }
      const start=230,end=380;
      // full waveform
      ctx.lineWidth=1.6; ctx.strokeStyle='#666'; ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y);
      for(const p of points) ctx.lineTo(p.x,p.y); ctx.stroke();
      // generated segment bold
      ctx.lineWidth=2.8; ctx.strokeStyle=ACCENT; ctx.beginPath(); ctx.moveTo(points[start].x,points[start].y);
      for(let i=start+1;i<=end;i++) ctx.lineTo(points[i].x,points[i].y); ctx.stroke();
      // sparse yellow heatmap outside generated segment with buffer
      const weights=new Array(points.length).fill(0);
      for(let i=0;i<points.length;i+=4){ if(i<start-20||i>end+20){ if(Math.random()<0.06){weights[i]=0.2+0.8*Math.random();} } }
      const max=Math.max(...weights);
      const barW=4; let idx=0;
      function drawBar(){
        if(idx>=points.length) return;
        if(weights[idx]>0){ const alpha=(weights[idx]/max)*0.55; ctx.fillStyle=`rgba(245,196,0,${alpha})`; ctx.fillRect(points[idx].x-barW/2,0,barW,H); }
        idx+=4; requestAnimationFrame(drawBar);
      }
      drawBar();
    })();
  </script>
</body>
</html>
